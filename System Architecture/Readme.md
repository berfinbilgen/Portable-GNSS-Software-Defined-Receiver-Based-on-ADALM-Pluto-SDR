Our portable GNSS receiver is organized as a two-layer system: an RF hardware chain and a software infrastructure. The software layer is further divided into (i) the GNU Radio runtime, which serves as the signal-processing execution engine, and (ii) the GNSS-SDR receiver, which implements the core GNSS functionality such as acquisition, tracking, telemetry decoding, and PVT computation. GNSS-SDR does not operate as a standalone program; it relies on GNU Radio to execute its processing blocks and on the ADALM-Pluto SDR to capture real GNSS L1/L2 signals.

At the hardware level, an active GNSS antenna receives weak spread-spectrum satellite signals. These signals are conditioned by the analog front-end (e.g., LNA filtering and biasing stages) and then fed into the ADALM-Pluto SDR. Inside the Pluto, the AD9363 RFIC downconverts the RF signal to baseband and digitizes it via ADC, producing complex I/Q samples. The I/Q representation corresponds to two orthogonal components of the same baseband signal (in-phase and 90° phase-shifted quadrature). The resulting sample stream is continuously transferred to the host PC over USB 2.0 through the Industrial I/O (IIO) interface. This is the primary data path that carries the digitized GNSS signal into the software receiver.

On the host PC, the I/Q stream enters the GNU Radio runtime. GNU Radio acts as the execution engine that schedules and runs digital signal processing blocks, manages buffers and dataflow between blocks, and enables efficient multithreaded processing. GNSS-SDR constructs its receiver as a graph of GNU Radio blocks; therefore, the GNSS-SDR “processing chain” (often shown as Signal Source → Signal Conditioner → Channels → Observables → PVT) is executed by GNU Radio under the hood. In this sense, GNU Radio provides the runtime environment, while GNSS-SDR provides the GNSS-specific receiver logic.

Within the GNSS-SDR flowgraph, the Signal Source block is the entry point where Pluto’s real-time I/Q samples are injected into the receiver. This block also participates in the control path: using libiio, it configures Pluto parameters such as center frequency (LO), sampling rate, RF bandwidth, and gain settings. After Signal Source, the Signal Conditioner standardizes the incoming samples (e.g., filtering, frequency adjustment, and resampling if required) so that downstream channels operate at the expected sampling conditions.

The conditioned stream is then processed by multiple parallel satellite channels. Each channel performs acquisition (search over code phase and Doppler), transitions to tracking (typically DLL/PLL-based code and carrier synchronization), and extracts navigation bits for telemetry decoding. Channel outputs—such as code phase, carrier phase, Doppler, and decoded navigation data—are aggregated in the Observables block to form synchronized measurements (e.g., pseudorange and Doppler observables) across satellites. Finally, the PVT block combines observables with decoded ephemerides to estimate receiver position, velocity, and clock bias. The PVT solution can be exported in standard formats and can also be streamed over UDP for external visualization and monitoring in a custom GUI.

Overall, the system has two complementary flows. The data path proceeds upward from Pluto → GNU Radio runtime → GNSS-SDR receiver blocks → PVT/monitor outputs. In the opposite direction, the control path proceeds from GNSS-SDR configuration → GNU Radio/Signal Source → Pluto hardware, enabling the receiver to both consume the digitized signal stream and actively configure the RF front-end.
